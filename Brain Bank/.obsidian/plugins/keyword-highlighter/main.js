/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => main_default
});
module.exports = __toCommonJS(main_exports);

// src/keyword-highlighter-plugin.ts
var import_obsidian3 = require("obsidian");

// src/editor-extension/highlight-mark.ts
var import_view = require("@codemirror/view");

// src/shared/font-modifiers.ts
var fontModifiers = /* @__PURE__ */ new Map([
  ["bold", "cm-strong"],
  ["italic", "cm-em"],
  ["underline", "kh-underline"],
  ["lineThrough", "kh-line-through"]
]);

// src/shared/get-css-classes.ts
function getCssClasses(keyword) {
  const classes = ["kh-highlighted"];
  if (keyword.fontModifiers) {
    keyword.fontModifiers.map((v) => fontModifiers.get(v)).filter((v) => v !== void 0).forEach((v) => classes.push(v));
  }
  return classes.join(" ");
}

// src/shared/color.ts
var Color = class {
  constructor(r, g, b) {
    this.r = r;
    this.g = g;
    this.b = b;
  }
  static fromHex(hex) {
    const hexPattern = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    if (!hexPattern) {
      console.warn("input is not a hex string");
      return new Color(0, 0, 0);
    }
    return new Color(
      parseInt(hexPattern[1], 16),
      parseInt(hexPattern[2], 16),
      parseInt(hexPattern[3], 16)
    );
  }
  static fromHsl(h, s, l) {
    const normalizedS = s / 100;
    const normalizedL = l / 100;
    const hueShift = (n) => (n + h / 30) % 12;
    const chroma = normalizedS * Math.min(normalizedL, 1 - normalizedL);
    const colorComponent = (n) => normalizedL - chroma * Math.max(-1, Math.min(hueShift(n) - 3, 9 - hueShift(n), 1));
    return new Color(
      Math.round(255 * colorComponent(0)),
      Math.round(255 * colorComponent(8)),
      Math.round(255 * colorComponent(4))
    );
  }
  static fromHslString(hslString) {
    const hslRegex = /hsl\(\s*(\d+),\s*(\d+)%,\s*(\d+)%\)/i;
    const match = hslString.match(hslRegex);
    if (!match) {
      console.warn("input is not a hsl string");
      return new Color(0, 0, 0);
    }
    const h = parseFloat(match[1]);
    const s = parseFloat(match[2]);
    const l = parseFloat(match[3]);
    return this.fromHsl(h, s, l);
  }
  static fromRgbString(rgbString) {
    const rgbRegex = /rgb\(\s*(\d+),\s*(\d+),\s*(\d+)\)/i;
    const match = rgbString.match(rgbRegex);
    if (!match) {
      console.warn("input is not a rgb string");
      return new Color(0, 0, 0);
    }
    const red = parseInt(match[1], 10);
    const green = parseInt(match[2], 10);
    const blue = parseInt(match[3], 10);
    return new Color(red, green, blue);
  }
  toHex() {
    return "#" + ((1 << 24) + (this.r << 16) + (this.g << 8) + this.b).toString(16).slice(1);
  }
  toHsl() {
    const r = this.r / 255, g = this.g / 255, b = this.b / 255;
    const max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h, s;
    const l = (max + min) / 2;
    if (max === min) {
      h = s = 0;
    } else {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;
        case g:
          h = (b - r) / d + 2;
          break;
        case b:
          h = (r - g) / d + 4;
          break;
        default:
          h = 0;
      }
      h /= 6;
    }
    return [Math.round(h * 360), Math.round(s * 100), Math.round(l * 100)];
  }
  toHslString() {
    const hsl = this.toHsl();
    return `hsl(${hsl[0]}, ${hsl[1]}, ${hsl[2]})`;
  }
};

// src/editor-extension/highlight-mark.ts
var highlightMark = (keyword) => {
  var _a, _b;
  const styles = [];
  const showColor = (_a = keyword.showColor) != null ? _a : true;
  if (showColor) {
    styles.push(`--kh-c: ${keyword.color}`);
  }
  const showBackgroundColor = (_b = keyword.showBackgroundColor) != null ? _b : true;
  if (showBackgroundColor) {
    styles.push(`--kh-bgc: ${keyword.backgroundColor}`);
  }
  return import_view.Decoration.mark({
    class: getCssClasses(keyword),
    attributes: {
      style: styles.join(";")
    }
  });
};

// src/editor-extension/editor-highlighter.ts
var import_search = require("@codemirror/search");
var import_state = require("@codemirror/state");
var import_view2 = require("@codemirror/view");
var EditorHighlighter = class {
  constructor(view) {
    this.decorations = this.buildDecorations(view);
  }
  update(update) {
    if (update.docChanged || update.viewportChanged) {
      this.decorations = this.buildDecorations(update.view);
    }
  }
  buildDecorations(view) {
    const builder = new import_state.RangeSetBuilder();
    const newDecorations = [];
    KeywordHighlighterPlugin.settings.keywords.filter((keyword) => !!keyword.keyword).forEach(
      (k) => newDecorations.push(...this.buildDecorationsForKeyword(view, k))
    );
    newDecorations.sort((a, b) => a.from - b.from);
    newDecorations.forEach((d) => builder.add(d.from, d.to, d.decoration));
    return builder.finish();
  }
  buildDecorationsForKeyword(view, keyword) {
    const newDecorations = [];
    const cursor = new import_search.SearchCursor(view.state.doc, `${keyword.keyword}`);
    cursor.next();
    while (!cursor.done) {
      newDecorations.push({
        from: cursor.value.from,
        to: cursor.value.to,
        decoration: highlightMark(keyword)
      });
      cursor.next();
    }
    return newDecorations;
  }
};
var editorHighlighter = import_view2.ViewPlugin.fromClass(EditorHighlighter, {
  decorations: (value) => value.decorations
});

// src/settings/setting-tab.ts
var import_obsidian = require("obsidian");

// src/settings/toggle-button-component.ts
var _container, _group, _options, _state, _onOptionClick;
var ToggleButtonComponent = class {
  constructor(container) {
    __privateAdd(this, _container, void 0);
    __privateAdd(this, _group, null);
    __privateAdd(this, _options, void 0);
    __privateAdd(this, _state, []);
    __privateAdd(this, _onOptionClick, void 0);
    __privateSet(this, _container, container);
  }
  setOptions(options) {
    __privateSet(this, _options, options);
    this.renderOptions();
    return this;
  }
  setState(newState) {
    __privateSet(this, _state, newState);
    this.renderOptions();
    return this;
  }
  setOnOptionClick(action) {
    __privateSet(this, _onOptionClick, action);
    this.renderOptions();
    return this;
  }
  renderOptions() {
    if (__privateGet(this, _group)) {
      __privateGet(this, _container).removeChild(__privateGet(this, _group));
    }
    __privateSet(this, _group, __privateGet(this, _container).createSpan());
    __privateGet(this, _group).classList.add("kh-toggle-group");
    for (const key of Object.keys(__privateGet(this, _options))) {
      this.createOptionButton(key, __privateGet(this, _group));
    }
  }
  createOptionButton(key, parent) {
    const optionButton = parent.createEl("button");
    optionButton.innerHTML = __privateGet(this, _options)[key];
    if (__privateGet(this, _state).contains(key)) {
      optionButton.classList.add("kh-toggle--checked");
    }
    optionButton.onclick = () => {
      this.toggleState(key);
      optionButton.classList.toggle("kh-toggle--checked");
      __privateGet(this, _onOptionClick).call(this, __privateGet(this, _state));
    };
    return optionButton;
  }
  toggleState(key) {
    if (__privateGet(this, _state).contains(key)) {
      __privateSet(this, _state, __privateGet(this, _state).filter((v) => v !== key));
    } else {
      __privateSet(this, _state, [...__privateGet(this, _state), key]);
    }
  }
};
_container = new WeakMap();
_group = new WeakMap();
_options = new WeakMap();
_state = new WeakMap();
_onOptionClick = new WeakMap();

// src/settings/generate-initial-colors.ts
function generateBackgroundColor() {
  const hue = Math.floor(Math.random() * 360);
  const saturation = Math.floor(60 + Math.random() * 10);
  const lightness = Math.floor(75 + Math.random() * 10);
  return Color.fromHsl(hue, saturation, lightness);
}
var colorBases = [
  "--color-base-00",
  "--color-base-05",
  "--color-base-10",
  "--color-base-20",
  "--color-base-25",
  "--color-base-30",
  "--color-base-35",
  "--color-base-40",
  "--color-base-50",
  "--color-base-60",
  "--color-base-70",
  "--color-base-100"
];
var colorFallback = "#000000";
function toColor(value) {
  if (value.startsWith("#")) {
    return Color.fromHex(value);
  } else if (value.startsWith("hsl")) {
    return Color.fromHslString(value);
  } else {
    return Color.fromRgbString(value);
  }
}
function luminance(color) {
  const normalizedValues = [color.r, color.g, color.b].map((colorComponent) => {
    const normalizedComponent = colorComponent / 255;
    return normalizedComponent <= 0.03928 ? normalizedComponent / 12.92 : Math.pow((normalizedComponent + 0.055) / 1.055, 2.4);
  });
  return normalizedValues[0] * 0.2126 + normalizedValues[1] * 0.7152 + normalizedValues[2] * 0.0722;
}
function contrastRatio(forgroundColor, backgroundColor) {
  const lum1 = luminance(forgroundColor);
  const lum2 = luminance(backgroundColor);
  const higherLum = Math.max(lum1, lum2);
  const lowerLum = Math.min(lum1, lum2);
  return (higherLum + 0.05) / (lowerLum + 0.05);
}
function chooseForeground(backgroundColor, container) {
  return colorBases.map((c) => container.getCssPropertyValue(c)).map((c) => c.length > 0 ? c : colorFallback).map((c) => toColor(c)).map((c) => ({ c, l: contrastRatio(c, backgroundColor) })).sort((a, b) => b.l - a.l)[0].c;
}
function generateInitialColors(container) {
  const backgroundColor = generateBackgroundColor();
  const foregroundColor = chooseForeground(backgroundColor, container);
  return [foregroundColor, backgroundColor];
}

// src/settings/checkbox-component.ts
var _container2, _element, _label, _state2, _onClick;
var CheckboxComponent = class {
  constructor(container) {
    __privateAdd(this, _container2, void 0);
    __privateAdd(this, _element, null);
    __privateAdd(this, _label, void 0);
    __privateAdd(this, _state2, false);
    __privateAdd(this, _onClick, void 0);
    __privateSet(this, _container2, container);
  }
  setLabel(label) {
    __privateSet(this, _label, label);
    this.render();
    return this;
  }
  setState(newState) {
    __privateSet(this, _state2, newState);
    this.render();
    return this;
  }
  setOnClick(action) {
    __privateSet(this, _onClick, action);
    this.render();
    return this;
  }
  render() {
    if (__privateGet(this, _element)) {
      __privateGet(this, _container2).removeChild(__privateGet(this, _element));
    }
    __privateSet(this, _element, __privateGet(this, _container2).createEl("input"));
    __privateGet(this, _element).type = "checkbox";
    __privateGet(this, _element).title = __privateGet(this, _label);
    __privateGet(this, _element).checked = __privateGet(this, _state2);
    __privateGet(this, _element).classList.add("kh-checkbox");
    __privateGet(this, _element).onclick = () => {
      __privateSet(this, _state2, !__privateGet(this, _state2));
      __privateGet(this, _onClick).call(this, __privateGet(this, _state2));
    };
  }
};
_container2 = new WeakMap();
_element = new WeakMap();
_label = new WeakMap();
_state2 = new WeakMap();
_onClick = new WeakMap();

// src/settings/setting-tab.ts
var SettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const keywordContainer = containerEl.createDiv();
    main_default.settings.keywords.forEach((k, i) => {
      this.createKeywordSetting(k, i, keywordContainer);
    });
    new import_obsidian.Setting(containerEl).addButton(
      (button) => button.setButtonText("Add new keyword").onClick(() => this.addKeywordSetting(keywordContainer))
    );
  }
  createKeywordSetting(keyword, index, container) {
    const setting = new import_obsidian.Setting(container).setName(`Keyword #${index}`).setDesc(
      "Enter a keyword, font modifiers, a font color and a background color"
    ).addText(
      (text) => text.setValue(keyword.keyword).onChange(async (value) => {
        keyword.keyword = value;
      })
    );
    this.addFontModifiers(setting, keyword);
    this.addFontColorConfig(setting, keyword);
    this.addBackgroundColorConfig(setting, keyword);
    this.addRemoveButton(setting, keyword, container);
    setting.controlEl.style.flexShrink = "0";
  }
  addFontModifiers(setting, keyword) {
    var _a;
    new ToggleButtonComponent(setting.controlEl).setOptions({
      bold: "<b>b</b>",
      italic: "<i>i</i>",
      underline: "<u>u</u>",
      lineThrough: "<s>s</s>"
    }).setState((_a = keyword.fontModifiers) != null ? _a : []).setOnOptionClick((modifiers) => keyword.fontModifiers = modifiers);
  }
  addFontColorConfig(setting, keyword) {
    var _a;
    new CheckboxComponent(setting.controlEl).setState((_a = keyword.showColor) != null ? _a : true).setLabel("Activate to modify the font color").setOnClick((state) => keyword.showColor = state);
    setting.addColorPicker(
      (cp) => cp.setValue(keyword.color).onChange(async (value) => {
        keyword.color = value;
      })
    );
  }
  addBackgroundColorConfig(setting, keyword) {
    var _a;
    new CheckboxComponent(setting.controlEl).setState((_a = keyword.showBackgroundColor) != null ? _a : true).setLabel("Activate to modify the background color").setOnClick((state) => keyword.showBackgroundColor = state);
    setting.addColorPicker(
      (cp) => cp.setValue(keyword.backgroundColor).onChange(async (value) => {
        keyword.backgroundColor = value;
      })
    );
  }
  addRemoveButton(setting, keyword, container) {
    setting.addExtraButton(
      (button) => button.setIcon("minus-with-circle").setTooltip("Remove keyword").onClick(async () => {
        const i = main_default.settings.keywords.indexOf(keyword);
        if (i > -1) {
          main_default.settings.keywords.splice(i, 1);
          const settingEl = container.getElementsByClassName("setting-item")[i];
          container.removeChild(settingEl);
        }
      })
    );
  }
  addKeywordSetting(container, value) {
    const [foregroundColor, backgroundColor] = generateInitialColors(container);
    main_default.settings.keywords.push({
      keyword: value != null ? value : "",
      color: foregroundColor.toHex(),
      backgroundColor: backgroundColor.toHex(),
      fontModifiers: [],
      showColor: true,
      showBackgroundColor: true
    });
    const newKeyword = main_default.settings.keywords.last();
    this.createKeywordSetting(
      newKeyword,
      main_default.settings.keywords.length - 1,
      container
    );
  }
  async hide() {
    main_default.settings.keywords = main_default.settings.keywords.filter(
      (k) => k.keyword && k.keyword.match(/^ *$/) === null
    );
    await this.plugin.saveSettings();
  }
};

// src/reader-extension/reader-highlighter.ts
var readerHighlighter = (el) => {
  main_default.settings.keywords.filter((keyword) => !!keyword.keyword).forEach((keyword) => replaceWithHighlight(el, keyword));
};
function replaceWithHighlight(node, keyword) {
  if (
    // skip highlighting nodes
    node.nodeType === Node.ELEMENT_NODE && node.classList.contains("kh-highlighted")
  ) {
    return;
  } else if (node.nodeType === Node.TEXT_NODE && node.nodeValue) {
    const searchText = `${keyword.keyword}`;
    const index = node.nodeValue.indexOf(searchText);
    if (index > -1) {
      const parent = node.parentNode;
      const beforeText = node.nodeValue.substring(0, index);
      const afterText = node.nodeValue.substring(index + searchText.length);
      const highlight = getHighlightNode(parent, searchText, keyword);
      parent.insertBefore(document.createTextNode(beforeText), node);
      parent.insertBefore(highlight, node);
      node.nodeValue = afterText;
      parent.childNodes.forEach(
        (child) => replaceWithHighlight(child, keyword)
      );
    }
    return;
  }
  node.childNodes.forEach((child) => replaceWithHighlight(child, keyword));
}
function getHighlightNode(parent, searchText, keyword) {
  var _a, _b;
  const highlight = parent.createSpan();
  highlight.classList.add(...getCssClasses(keyword).split(" "));
  const showColor = (_a = keyword.showColor) != null ? _a : true;
  if (showColor) {
    highlight.style.setProperty("--kh-c", keyword.color);
  }
  const showBackgroundColor = (_b = keyword.showBackgroundColor) != null ? _b : true;
  if (showBackgroundColor) {
    highlight.style.setProperty("--kh-bgc", keyword.backgroundColor);
  }
  highlight.setText(searchText);
  return highlight;
}

// src/commands/create-command.ts
var import_obsidian2 = require("obsidian");
var settingTabId = "keyword-highlighter";
function openSettingsAndAddKeyword(app, value) {
  const setting = app.setting;
  setting.open();
  setting.openTabById(settingTabId);
  const settingTab = setting.pluginTabs.find(
    (tab) => tab.id === settingTabId
  );
  const keywordContainer = settingTab.containerEl.firstElementChild;
  settingTab.addKeywordSetting(keywordContainer, value);
}
var createCommand = (app) => ({
  id: "kh-create-new-keyword",
  name: "Add a new keyword",
  callback: () => {
    let selection;
    const view = app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
    if (view && view.getMode() === "source") {
      selection = view.editor.getSelection().trim();
      if (selection.endsWith(":")) {
        selection = selection.slice(0, -1);
      }
    }
    openSettingsAndAddKeyword(app, selection);
  }
});

// src/keyword-highlighter-plugin.ts
var DEFAULT_SETTINGS = {
  keywords: [
    {
      keyword: "TODO",
      color: "#000",
      backgroundColor: "#A9CCE3",
      fontModifiers: [],
      showColor: true,
      showBackgroundColor: true
    },
    {
      keyword: "ADD",
      color: "#000",
      backgroundColor: "#8DE3C2",
      fontModifiers: [],
      showColor: true,
      showBackgroundColor: true
    },
    {
      keyword: "FIXME",
      color: "#000",
      backgroundColor: "#BAA2E8",
      fontModifiers: [],
      showColor: true,
      showBackgroundColor: true
    }
  ]
};
var KeywordHighlighterPlugin = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    this.registerEditorExtension(editorHighlighter);
    this.registerMarkdownPostProcessor(readerHighlighter);
    this.addCommand(createCommand(this.app));
    this.addSettingTab(new SettingTab(this.app, this));
  }
  async loadSettings() {
    KeywordHighlighterPlugin.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
    this.refreshMarkdownView();
  }
  async saveSettings() {
    await this.saveData(KeywordHighlighterPlugin.settings);
    this.refreshMarkdownView();
  }
  refreshMarkdownView() {
    const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
    markdownView == null ? void 0 : markdownView.previewMode.rerender(true);
    const editorView = markdownView == null ? void 0 : markdownView.editor.cm;
    if (editorView) {
      editorView.setState(editorView.state);
    }
  }
};

// main.ts
var main_default = KeywordHighlighterPlugin;
